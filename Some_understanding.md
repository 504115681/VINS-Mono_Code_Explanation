

# 6月8日 

## 第1章-第4讲-ROS简介

1、find 命令，找文件

```
-name<范本样式>：指定字符串作为寻找文件或目录的范本样式；
```

```latex
x@x-Legion-Y7000P-2019:~/catkin_ws5/src/PL-VIO-OK$ find ./ -name "package.xml"
./camera_model/package.xml
./vins_estimator/package.xml
./benchmark_publisher/package.xml
./feature_tracker/package.xml
./sim_data_pub/package.xml
./pose_graph/package.xml
```

2、VINS有三个可执行文件，三个节点。

3、ROS缺点：

数据COPY次数过多。（4次COPY）

## 第1章-第5讲-坐标系定义

1、VINS里面都是右手系。

2、

相机坐标系：

IMU坐标系：

3、第一个参考帧设为世界坐标系。因为有IMU所以重力方向已知，将世界坐标系z轴与重力方向对齐，roll和pitch可以求出来。

于是初始位姿为：（0,0,0,roll,pitch,0）。

4、twc是相机坐标系到世界坐标系的平移向量（以世界坐标系为参考坐标系）。也是相机坐标系相对于世界坐标系。写完整为：w^twc(w在左上角)。

# 6月10日 

## 第2章-第1讲-前端光流代码讲解（1）

1、声明一个句柄，～代表这个节点的命名空间。实际上发出去的是：**/feature_tracker**/feature

```c++
ros::init(argc, argv, "feature_tracker");//ros节点初始化,指定节点的名称"feature_tracker"。节点的名称必须唯一(名称内不能包含 / 等符号)

ros::NodeHandle n("~");//声明一个句柄，～代表这个节点的命名空间。
pub_img = n.advertise<sensor_msgs::PointCloud>("feature", 1000);   //发布跟踪的特征点信息。实际上发出去的是：/feature_tracker/feature
```

2、频率控制。

如果实际发布频率大于设定值10HZ，肯定就不发了，因为图片为30HZ，担心后端处理不过来。所以，要想发布图像帧，那么实际频率要比设定值10HZ小。

但是，如果实际频率与设定频率的累积误差大于0.01倍的设定频率了，重新计数。因为当误差很小时，说明分母很大了，即使1s发的超过了设定的频率值，可能也不会判断出来啦，需要将分母清0。

**注意！即使不发布该帧话题，也会进行光流追踪。**

```c++
// frequency control  f = 1 / T ,频率=1秒/周期，周期=1秒/频率
if (round(1.0 * pub_count / (img_msg->header.stamp.toSec() - first_image_time)) <= FREQ)//round()四舍五入
{
	PUB_THIS_FRAME = true;
	// reset the frequency control     即：实际频率 >0.99 * FREQ，说明实际频率快超过设定频率了，重新计数。
	if (abs(1.0 * pub_count / (img_msg->header.stamp.toSec() - first_image_time) - FREQ) < 0.01 * FREQ)
	{
		first_image_time = img_msg->header.stamp.toSec();
		pub_count = 0;
	}
}
else
	PUB_THIS_FRAME = false;
```

## 第2章-第2讲-前端光流代码讲解（2）

1、**LK金字塔光流追踪：**

```c++
cv::calcOpticalFlowPyrLK(cur_img, forw_img, cur_pts, forw_pts, status, err, cv::Size(21, 21), 3);
```

通过上一帧的特征点进行跟踪，得到现在这一帧的特征点。**而不是提取上一帧和当前帧的特征点，然后再匹配和跟踪。**

参数设为3,总共4层。最上面的是L3，最小。最下面是L0。

上一层金字塔追踪结果作为下一层金字塔追踪结果的初值。（做4遍光流追踪，时间会多一点。）

- 既避免了不用金字塔导致光流法中小运动假设不满足，陷入局部最优；
- 又避免用金字塔导致精度下降（如果只用最上面的追踪结果，然后乘上比例，扩大到最下层，会导致像素误差从1个像素变的更大）。

2、瘦身，双指针去除特定值。时间复杂度：O（n），空间复杂度：0。

```c++
void reduceVector(vector<cv::Point2f> &v, vector<uchar> status)
{
	int j = 0;
	for (int i = 0; i < int(v.size()); i++)
        if (status[i])
			v[j++] = v[i];
	v.resize(j);
}
```

3、

void FeatureTracker::rejectWithF()

首先根据不同的相机模型将二维坐标转换到去畸变前的三维坐标，即像素坐标左成内参矩阵的逆到去畸变前的三维坐标，然后去畸变，然后再到归一化平面，然后再通过虚拟相机的内参（fx=FOCAL_LENGTH;fy=FOCAL_LENGTH;cx=COL / 2.0;cy=ROW / 2.0）到像素坐标。

```
//根据不同的相机模型将二维坐标转换到三维坐标，并去畸变。
m_camera->liftProjective(Eigen::Vector2d(cur_pts[i].x, cur_pts[i].y), tmp_p);
//对于PINHOLE（针孔相机）可将三维坐标转换到归一化平面，再通过虚拟相机的内参到像素坐标。
tmp_p.x() = FOCAL_LENGTH * tmp_p.x() / tmp_p.z() + COL / 2.0;//焦点距离（focal length  FOCAL_LENGTH）

tmp_p.y() = FOCAL_LENGTH * tmp_p.y() / tmp_p.z() + ROW / 2.0;

un_cur_pts[i] = cv::Point2f(tmp_p.x(), tmp_p.y());
```

## 第2章-第4讲-光流前端vs描述子前端

光流法特征跟踪比描述子稍微鲁棒一些（ORB SLAM作者这么说的）。其实对于相邻帧特征跟踪，光流法更快。而描述子主要是用来做回环检测、重定位，也就是时间差了比较多的帧之间，中间有遮挡或者看不到也没事，还可以检测出来是同一个特征点。

## 第2章-第5讲-高效去畸变方式

离中心点越远，畸变越大。

畸变前的点-->畸变后的点，是正向过程，比较好算。但是去畸变过程，比较难。

VINS中是：逐次逼近式去畸变。

# 6月12日 

## 第3章-第1讲-旋转的定义

旋转的几种数学表示方法：

1、旋转矩阵：运算方便；使用9个量描述3自由度旋转。缺点:引入额外约束：单位正交阵，求导困难。

2、旋转向量：紧凑的表示旋转。缺点:具有周期性。

3、欧拉角：直观，用户友好。缺点:需要指定旋转顺序（比如：先转Z再Y再X轴），存在万象节死锁问题，无法进行球面平滑插值。

4、四元数：紧凑的不带奇异的表示方法。缺点：对用户来讲不太直观；要求单位四元数，表示旋转也会过参数化（4个参数表示3个自由度）。[qw,qx,qy,qz]^T^=[cos(sita/2),n向量点乘sin(sita/2)]^T^。

![image-20210612134308101](笔记.assets/image-20210612134308101.png)

![image-20210612134004472](笔记.assets/image-20210612134004472.png)

因为IMU频率大概100HZ，0.01s角度变化很小，趋近于0。

# 7月4日 

## 第3章-第2讲-连续时间积分

1、课程中，四元数实部在前，虚部在后。

关键是推导了四元数的导数：

![image-20210706113839891](笔记.assets/image-20210706113839891.png)

2、我做的PPT里面的推导：

与论文中四元数格式一致：四元数虚部在前，实部在后。

2.1、下面的qt导，是世界坐标系下的。

![image-20210704211306066](笔记.assets/image-20210704211306066.png)

2.2、四元数乘法转换到矩阵乘法。

![image-20210704211314034](笔记.assets/image-20210704211314034.png)

## 第3章-第3讲-为什么需要预积分

1、滤波问题中IMU积分：

- IMU为预测。
- 图像是更新。

IMU得到状态估计中的预测值，图像帧的重投影误差得到观测值。

2、连续时间下预积分：

这三个是一个帧间约束。

![image-20210704221002144](笔记.assets/image-20210704221002144.png)

3、离散时间预积分量中值积分：

将加速度转到bk坐标系下，然后用中值法表示加速度和加速度。

![image-20210706114010187](笔记.assets/image-20210706114010187.png)

## 第3章-第4讲-误差卡尔曼滤波

本讲介绍如何计算预积分量的协方差矩阵，也就是置信度。

1、什么是误差卡尔曼滤波？

输入到卡尔曼滤波器的是误差量。

![image-20210704224558493](笔记.assets/image-20210704224558493.png)

2、为什么用误差卡尔曼滤波？

待定。现在还不懂。

3、误差卡尔曼滤波相关概念。

名义值：估计出/测量出来的非常接近真值的值。

![image-20210704225706593](笔记.assets/image-20210704225706593.png)

4、旋转是3自由度，而四元数4个参数，转化为旋转向量：3个参数表示。避免过参数化。

![image-20210704225911742](笔记.assets/image-20210704225911742.png)

# 7月5日

## 第3章-第5讲-连续时间预积分误差传递

论文公式29推导。

1、推导**deta β**的导数：

忽略二阶小量（两个一阶小量相乘）

![image-20210705102332840](笔记.assets/image-20210705102332840.png)

2、推导**deta sita**的导数：

①四元数相乘然后求导，满足(x * y)‘=x' * y + y' * x；

②四元数相乘等号左右两边可以抵消；

③四元数可以写成轴角形式；

④反对称矩阵满足加法结合律；

⑤忽略二阶小量（两个一阶小量相乘）；

![image-20210705104453243](笔记.assets/image-20210705104453243.png)

## 第3章-第6讲-离散时间预积分误差传递（1）

需要从连续时间变离散时刻，如何？后面会推导。

1、因为用了中值积分，和相邻两个时刻：k、k+1时刻有关，将噪声项 nt 从12 * 1扩展到18 * 1。而零偏不区分k时刻和k+1时刻，在这段时间内为同一个值。

![image-20210705111737667](笔记.assets/image-20210705111737667.png)

2、离散时间角度误差的推导。

![image-20210705112938341](笔记.assets/image-20210705112938341.png)

![image-20210705164130997](笔记.assets/image-20210705164130997.png)

3、离散时间速度误差的推导。

![image-20210705163602863](笔记.assets/image-20210705163602863.png)

![image-20210705164249934](笔记.assets/image-20210705164249934.png)

![image-20210705164136963](笔记.assets/image-20210705164136963.png)

4、离散时间位置误差的推导。

![image-20210705165157826](笔记.assets/image-20210705165157826.png)

5、离散时间零偏误差的推导。

![image-20210705170544801](笔记.assets/image-20210705170544801.png)

6、基于中值积分的离散时间预积分误差传递。

![image-20210705170147066](笔记.assets/image-20210705170147066.png)

## 第3章-第8讲-预积分零偏建模方式

1、预积分中关于IMU零偏的建模。

![image-20210705171022718](笔记.assets/image-20210705171022718.png)

bias是我们需要优化的变量，当每次迭代时，我们得到一个新的 bias，需要根据上式重新进行IMU预积分，非常耗时。

当bias的变化量很小时，我们可以用一阶泰勒展开来获取它们的近似值：

![image-20210705171231676](笔记.assets/image-20210705171231676.png)

2、如何计算预积分量关于零偏的雅可比。

![image-20210705171500813](笔记.assets/image-20210705171500813.png)

![image-20210705171801122](笔记.assets/image-20210705171801122.png)

3、预积分协方差矩阵的传递。

①一些协方差性质。（F是矩阵）

![image-20210705172015169](笔记.assets/image-20210705172015169.png)

②传递：

![image-20210705172115347](笔记.assets/image-20210705172115347.png)

## 第3章-第9讲-预积分代码讲解

1、四元数归一化表示旋转。单位四元数表示没有旋转，也就是单位旋转矩阵。

2、零偏在两帧图像之间的IMU预积分过程中不变。

3、midPointIntegration()中求qi+1时，四元数没有归一化，但是由于_dt很小，忽略也可以，误差相差不大。

```c++
result_delta_q = delta_q * Quaterniond(1, un_gyr(0) * _dt / 2, un_gyr(1) * _dt / 2, un_gyr(2) * _dt / 2);
```

4、三种反对称矩阵先用三个变量表示。

![image-20210705180058708](笔记.assets/image-20210705180058708.png)

![image-20210705180130942](笔记.assets/image-20210705180130942.png)

5、代码和论文差负号。没什么影响，因为高斯噪声na、nw正负都可以，表示同一个噪声。

![image-20210705180644879](笔记.assets/image-20210705180644879.png)

6、更新协方差矩阵，方便后面VIO优化用。

更新雅可比矩阵，方便当bias变化量很小时，不用重新进行预积分，可以用一阶泰勒展开来获取预积分量的近似值。

# 7月6日

## 第4章-第1讲-VIO初始化做了什么

1、为什么需要初始化？

单目紧耦合VIO是一个高度非线性系统，需要一个精确的初始值作为优化的起点。这个初始值比较接近真实值，使得优化更容易收敛。初始值通过视觉-IMU松耦合就可以得到。

2、初始化哪些变量？

PVQ，零偏，外参，地图点逆深度。

![image-20210706085728581](笔记.assets/image-20210706085728581.png)

3、初始化不去解决哪些变量？

外参平移和加速度偏置ba难以估计，所以初始化不去估计。

其中，平移外参可以自己用尺子测量，给一个初始的值。

加速度偏置ba很难与重力区分出来。如果忽略了ba，也不会影响初始化结果。

## 第4章-第2讲-数据预处理（01）

1、默认特征点误差在1.5个像素单位范围内，如果误匹配，则后面用核函数去抑制误匹配的影响。

![image-20210706091701084](笔记.assets/image-20210706091701084.png)

2、线程锁：避免线程冲突；条件变量：避免CPU内存资源占用过高。

![image-20210706092548929](笔记.assets/image-20210706092548929.png)

3、imu_callback()两个作用：将imu消息存进buffer；同时按照imu频率预测位姿并发送，这样可以提高里程计频率。

![image-20210706093633291](笔记.assets/image-20210706093633291.png)

![image-20210706093408178](笔记.assets/image-20210706093408178.png)

![image-20210706105812073](笔记.assets/image-20210706105812073.png)

## 第4章-第3讲-数据预处理（02）

1、pre_integrations[frame_count]->push_back：更新预积分量。

tmp_pre_integration->push_back：用来初始化用的，初始化之后用不到。

![image-20210706105333412](笔记.assets/image-20210706105333412.png)

2、又是一个中值积分，更新滑窗中状态量，本质是给分线性优化提供可信的初值。

![image-20210706105635087](笔记.assets/image-20210706105635087.png)

3、processIMU()作用总结：

对IMU数据进行处理，包括更新预积分量，和提供优化状态量的初始值。

![image-20210706105925482](笔记.assets/image-20210706105925482.png)

## 第4章-第4讲-数据预处理（03）

1、

![image-20210706111335589](笔记.assets/image-20210706111335589.png)

2、①初始化时，即使中间一帧的图像不是关键帧，也希望把预积分量保留下来，所以用到了tmp_pre_integration这个变量。

![image-20210706112605921](笔记.assets/image-20210706112605921.png)

②无论这一帧是否为关键帧，都会更新临时预积分初始值tmp_pre_integration。

![image-20210706112644671](笔记.assets/image-20210706112644671.png)

③然后将预积分值存进来。

![image-20210706112750702](笔记.assets/image-20210706112750702.png)

④而优化时，尽可能希望滑窗中覆盖的距离远，防止优化陷入局部最优，就需要扔掉非关键帧，只保留关键帧的预积分。

![image-20210706113315083](笔记.assets/image-20210706113315083.png)

